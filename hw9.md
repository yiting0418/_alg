[Gemini](https://gemini.google.com/share/ba959fead125)

將 'horse' 轉換成 'ros' 的過程：

=== 1. 初始化表格邊框 ===
邊框初始化完成 (第一列代表全插入，第一欄代表全刪除)。

=== 2. 開始填表推論 ===
正在計算 dp[1][1] ( 'h' -> 'r' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'h'): 1
    - 左 (插入 'r'): 1
    - 左上 (替換): 0
  [選擇] 最小鄰居是 0，動作是: 【替換 (Substitute)】
  [計算] 0 + 1 = 1
正在計算 dp[1][2] ( 'h' -> 'o' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'h'): 2
    - 左 (插入 'o'): 1
    - 左上 (替換): 1
  [選擇] 最小鄰居是 1，動作是: 【替換 (Substitute)】
  [計算] 1 + 1 = 2
正在計算 dp[1][3] ( 'h' -> 's' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'h'): 3
    - 左 (插入 's'): 2
    - 左上 (替換): 2
  [選擇] 最小鄰居是 2，動作是: 【替換 (Substitute)】
  [計算] 2 + 1 = 3
正在計算 dp[2][1] ( 'o' -> 'r' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'o'): 1
    - 左 (插入 'r'): 2
    - 左上 (替換): 1
  [選擇] 最小鄰居是 1，動作是: 【替換 (Substitute)】
  [計算] 1 + 1 = 2
正在計算 dp[2][2] ( 'o' -> 'o' )
  [判定] 字元相同！
  [動作] 直接繼承左上角 (Pass/Match)
  [數值] 1 (不加分)
正在計算 dp[2][3] ( 'o' -> 's' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'o'): 3
    - 左 (插入 's'): 1
    - 左上 (替換): 2
  [選擇] 最小鄰居是 1，動作是: 【插入 (Insert)】
  [計算] 1 + 1 = 2
正在計算 dp[3][1] ( 'r' -> 'r' )
  [判定] 字元相同！
  [動作] 直接繼承左上角 (Pass/Match)
  [數值] 2 (不加分)
正在計算 dp[3][2] ( 'r' -> 'o' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'r'): 1
    - 左 (插入 'o'): 2
    - 左上 (替換): 2
  [選擇] 最小鄰居是 1，動作是: 【刪除 (Delete)】
  [計算] 1 + 1 = 2
正在計算 dp[3][3] ( 'r' -> 's' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'r'): 2
    - 左 (插入 's'): 2
    - 左上 (替換): 1
  [選擇] 最小鄰居是 1，動作是: 【替換 (Substitute)】
  [計算] 1 + 1 = 2
正在計算 dp[4][1] ( 's' -> 'r' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 's'): 2
    - 左 (插入 'r'): 4
    - 左上 (替換): 3
  [選擇] 最小鄰居是 2，動作是: 【刪除 (Delete)】
  [計算] 2 + 1 = 3
正在計算 dp[4][2] ( 's' -> 'o' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 's'): 2
    - 左 (插入 'o'): 3
    - 左上 (替換): 2
  [選擇] 最小鄰居是 2，動作是: 【替換 (Substitute)】
  [計算] 2 + 1 = 3
正在計算 dp[4][3] ( 's' -> 's' )
  [判定] 字元相同！
  [動作] 直接繼承左上角 (Pass/Match)
  [數值] 2 (不加分)
正在計算 dp[5][1] ( 'e' -> 'r' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'e'): 3
    - 左 (插入 'r'): 5
    - 左上 (替換): 4
  [選擇] 最小鄰居是 3，動作是: 【刪除 (Delete)】
  [計算] 3 + 1 = 4
正在計算 dp[5][2] ( 'e' -> 'o' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'e'): 3
    - 左 (插入 'o'): 4
    - 左上 (替換): 3
  [選擇] 最小鄰居是 3，動作是: 【替換 (Substitute)】
  [計算] 3 + 1 = 4
正在計算 dp[5][3] ( 'e' -> 's' )
  [判定] 字元不同！檢查三個鄰居：
    - 上 (刪除 'e'): 2
    - 左 (插入 's'): 4
    - 左上 (替換): 3
  [選擇] 最小鄰居是 2，動作是: 【刪除 (Delete)】
  [計算] 2 + 1 = 3

=== 3. 最終表格 (DP Table) ===
         #  r  o  s 
#  [  0  1  2  3 ]
h  [  1  1  2  3 ]
o  [  2  2  1  2 ]
r  [  3  2  2  2 ]
s  [  4  3  3  2 ]
e  [  5  4  4  3 ]

最終最小編輯距離: 3


# 程式碼解釋

表格初始化 (dp table):

我們建立一個大小為 (m+1)×(n+1) 的矩陣。

第一行 (Row 0) 代表將空字串變成 word2 的前 j 個字，代價就是 j（插入 j 次）。

第一欄 (Col 0) 代表將 word1 的前 i 個字變成空字串，代價就是 i（刪除 i 次）。

雙重迴圈 (for loops):

我們從索引 1 開始遍歷每個字元。

Python 的索引是從 0 開始的，所以 word1[i-1] 實際上是指當前正在比較的字元。

決策邏輯:

程式核心在於 min() 函式的比較，它保證了我們每一步都選擇了代價最小的路徑。

複雜度分析

時間複雜度: O(m×n)，其中 m 和 n 是兩個字串的長度。

空間複雜度: O(m×n)，用於儲存 dp 表格。

注意： 如果只需要計算距離而不需要回溯路徑，空間複雜度可以優化至 O(min(m,n))，因為每次更新只需要用到上一列的資訊。
